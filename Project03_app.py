# -*- coding: utf-8 -*-
#"""VICTORPROJECT.ipynb

#Automatically generated by Colab.

#Original file is located at
    #https://colab.research.google.com/drive/1vkM4-cSMcSvKQve30U-8fcm4kB6I97u7
#"""

import streamlit as st
import sqlite3, smtplib, random, string, bcrypt, pandas as pd, json, re, hashlib, secrets
from typing import List
from email.message import EmailMessage
from datetime import datetime
import streamlit.components.v1 as components
 
 # â”€â”€â”€ Streamlit Theme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.set_page_config(page_title="ANOMALYZED SENTINEL", layout="wide")
st.markdown(
    """
    <style>
    .stApp {
        background: linear-gradient(to bottom, #cc99ff 4%, #999966 84%);
     }
     section[data-testid="stSidebar"] {
         background: rgb(166, 138, 77);
     }
     h1, h2, h3, h4, h5, h6 {
         color: #3df50a;
     }
     .stButton > button {
         color: #3df50a !important;
         font-weight: 900;
     }
     </style>
     """,
     unsafe_allow_html=True,
 )
def create_users_table():
    conn = sqlite3.connect("users.db")
    c = conn.cursor()

    # --- USERS TABLE ---
    c.execute(
        """
        CREATE TABLE IF NOT EXISTS users(
            username TEXT PRIMARY KEY,
            password BLOB NOT NULL,
            email TEXT UNIQUE NOT NULL,
            is_admin INTEGER DEFAULT 0,
            otp TEXT,
            otp_expiry TEXT,
            verified INTEGER DEFAULT 0,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
        """
    )

    # --- RESET CODES TABLE ---
    c.execute(
        """
        CREATE TABLE IF NOT EXISTS reset_codes(
            email TEXT PRIMARY KEY,
            code TEXT,
            expiry_time TEXT
        )
        """
    )

    # --- ACTIVITY LOGS TABLE ---
    c.execute(
        """
        CREATE TABLE IF NOT EXISTS activity_logs(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT,
            action TEXT,
            ip_address TEXT,
            user_agent TEXT,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP
        )
        """
    )

    # --- LOGIN ATTEMPTS TABLE ---
    c.execute(
        """
        CREATE TABLE IF NOT EXISTS login_attempts(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT,
            success INTEGER,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP
        )
        """
    )

    # --- ADMIN ACTIONS TABLE ---
    c.execute(
        """
        CREATE TABLE IF NOT EXISTS admin_actions(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            admin_user TEXT,
            target_user TEXT,
            action TEXT,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP
        )
        """
    )

    conn.commit()
    conn.close()
def ensure_reset_codes_table():
    """
    Ensure the reset_codes table exists with the expected schema.
    If an incompatible schema exists, drop and recreate the table.
    """
    conn = sqlite3.connect("users.db")
    c = conn.cursor()

    # If table doesn't exist, create it (safe)
    c.execute("""
        CREATE TABLE IF NOT EXISTS reset_codes(
            email TEXT PRIMARY KEY,
            code TEXT,
            expiry_time TEXT
        )
    """)
    conn.commit()

    # Check current schema
    c.execute("PRAGMA table_info(reset_codes)")
    cols = {row[1]: row[2].upper() for row in c.fetchall()}  # {name: type}
    expected = {"email": "TEXT", "code": "TEXT", "expiry_time": "TEXT"}

    # If any expected column missing or type differs, recreate table
    mismatch = False
    for k, t in expected.items():
        if k not in cols or cols[k] != t:
            mismatch = True
            break

    if mismatch:
        # drop and recreate (keeps DB stable, but loses reset_codes only)
        try:
            c.execute("DROP TABLE IF EXISTS reset_codes")
            c.execute("""
                CREATE TABLE reset_codes(
                    email TEXT PRIMARY KEY,
                    code TEXT,
                    expiry_time TEXT
                )
            """)
            conn.commit()
            print("[DB MIGRATION] reset_codes table recreated to expected schema.")
        except Exception as e:
            print("[DB MIGRATION ERROR]", e)
    conn.close()

def add_user(u, pw, email, adm=False):
     conn = sqlite3.connect("users.db")
     c = conn.cursor()
     if c.execute(
         "SELECT 1 FROM users WHERE username=? OR email=?", (u, email)
     ).fetchone():
         conn.close()
         raise ValueError("Username or email already exists.")
     c.execute(
         "INSERT INTO users VALUES (?, ?, ?, ?)",
         (u, bcrypt.hashpw(pw.encode(), bcrypt.gensalt()), email, int(adm)),
     )
     conn.commit()
     conn.close()
def login_user(u, pw):
     """
     Authenticate user by username and password.
     Returns (True, user_dict) on success, else (False, {}).
     """
     conn = sqlite3.connect("users.db")
     c = conn.cursor()
     row = c.execute(
         "SELECT password, is_admin FROM users WHERE username=?", (u,)
     ).fetchone()
     conn.close()
     if row and bcrypt.checkpw(pw.encode(), row[0]):
         return True, {"username": u, "is_admin": bool(row[1])}
     return False, {}
def log_event(user, action):
     conn = sqlite3.connect("users.db")
     conn.execute(
         "INSERT INTO activity_logs(username, action, timestamp) VALUES (?, ?, ?)",
         (user, action, datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
     )
     conn.commit()
     conn.close()
def delete_user(u):
     conn = sqlite3.connect("users.db")
     conn.execute("DELETE FROM users WHERE username=?", (u,))
     conn.commit()
     conn.close()
def fetch_user(username_or_email):
     """Retrieve user info from DB by username or email."""
     conn = sqlite3.connect("users.db")
     cursor = conn.cursor()
     cursor.execute(
         """
         SELECT username, email, password, is_admin
         FROM users
         WHERE username = ? OR email = ?
         """,
         (username_or_email, username_or_email),
     )
     row = cursor.fetchone()
     conn.close()
     if row:
         return {
             "username": row[0],
             "email": row[1],
             "password_hash": row[2],
             "is_admin": bool(row[3]),
         }
     return None
def check_password(plain_password, hashed_password):
     """Compare a plain text password with a hashed one using bcrypt."""
     return bcrypt.checkpw(plain_password.encode(), hashed_password)
def update_user_profile(username, new_username=None, new_email=None):
    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    updates = []
    params = []
    if new_username and new_username != username:
        updates.append("username = ?")
        params.append(new_username)
    if new_email:
        updates.append("email = ?")
        params.append(new_email)
    if not updates:
        conn.close()
        return "No updates provided."
    params.append(username)
    query = f"UPDATE users SET {', '.join(updates)} WHERE username = ?"
    c.execute(query, tuple(params))
    conn.commit()
    conn.close()
    return "Profile updated successfully."

def change_user_password(username, old_password, new_password):
    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    c.execute("SELECT password FROM users WHERE username=?", (username,))
    row = c.fetchone()
    if not row:
        conn.close()
        return "User not found."
    if not bcrypt.checkpw(old_password.encode(), row[0]):
        conn.close()
        return "Old password incorrect."
    hashed = bcrypt.hashpw(new_password.encode(), bcrypt.gensalt())
    c.execute("UPDATE users SET password=? WHERE username=?", (hashed, username))
    conn.commit()
    conn.close()
    return "Password changed successfully."

def send_otp(email):
     otp = str(random.randint(100_000, 999_999))
     print(f"[DEBUG] Sending OTP {otp} to {email}")
     msg = EmailMessage()
     msg.set_content(f"Your One-Time Password (OTP) is: {otp}")
     msg["Subject"] = "Your OTP Code"
     msg["From"] = "isaackmutembei335@gmail.com"
     msg["To"] = email
     try:
         with smtplib.SMTP("smtp.gmail.com", 587) as server:
             server.starttls()
             server.login("isaackmutembei335@gmail.com", "ojaz blqw lmza kqpg")
             server.send_message(msg)
             print("[DEBUG] Email sent successfully.")
     except Exception as e:
         print("[ERROR] Failed to send OTP:", e)
 
     return otp
 # â”€â”€â”€ Core Security / Analysis Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def detect_anomalies(df):
     num = df.select_dtypes(include="number")
     if num.empty:
         raise ValueError("No numeric columns.")
     rs = num.sum(axis=1)
     return df[rs > rs.mean()]
_PAT = {
     "urgent": r"urgent",
     "click here": r"click\s+here",
     "verify": r"verify\s+(your\s+)?account",
     "login now": r"login\s+(now|here)",
     "update pass": r"update\s+(your\s+)?password",
     "acct suspend": r"account\s+(suspended|limited|compromised)",
     "security": r"security\s+(alert|update)",
     "unusual": r"unusual\s+activity",
     "confirm": r"confirm\s+your\s+identity",
     "request": r"provide\s+(credit\s+card|ssn|password)",
     "act now": r"(act\s+)?now\s+to\s+avoid\s+.*",
     "win": r"(you\s+have\s+)?won\s+.*",
 }
def is_phishing(txt): return any(re.search(p, txt.lower()) for p in _PAT.values())
def explain_phishing_detection(txt): return [k for k, p in _PAT.items() if re.search(p, txt.lower())]
def create_order_hash(o): return hashlib.sha256(json.dumps(o, sort_keys=True).encode()).hexdigest()
def scan_vulnerabilities(f):
     try:
         df = (
             pd.read_csv(f)
             if f.name.endswith(".csv")
             else pd.DataFrame(f.read().decode().splitlines(), columns=["software"])
         )
         vuln = df[
             df.apply(
                 lambda r: r.astype(str).str.contains("old|deprecated", case=False).any(),
                 axis=1,
             )
         ]
         return vuln, ""
     except Exception as e:
         return pd.DataFrame(), str(e)
def simulate_network_logs():
     ips = ["192.168.1.2", "10.0.0.5", "172.16.0.3", "203.0.113.10"]
     actions = ["login", "file_access", "failed_login", "port_scan", "data_transfer"]
     return [
         {
             "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
             "ip": random.choice(ips),
             "action": random.choice(actions),
             "status": random.choice(["success", "failure"]),
         }
         for _ in range(15)
     ]
def detect_suspicious_activity(logs):
     return [
         l
         for l in logs
         if l["action"] in ["failed_login", "port_scan"]
         or (l["action"] == "data_transfer" and l["status"] == "failure")
     ]
def analyze_behavior(logs):
     summ = {}
     for l in logs:
         summ.setdefault(l["ip"], {"logins": 0, "fail": 0, "scan": 0})
         if l["action"] == "login":
             summ[l["ip"]]["logins"] += 1
         elif l["action"] == "failed_login":
             summ[l["ip"]]["fail"] += 1
         elif l["action"] == "port_scan":
             summ[l["ip"]]["scan"] += 1
     return {ip: s for ip, s in summ.items() if s["fail"] >= 3 or s["scan"] > 0}
     
 # â”€â”€â”€ Module Pages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def ai_threat_engine():
     st.header("A.I Threat Engine")
     f = st.file_uploader("Upload CSV/TXT", type=["csv", "txt"])
     if f:
         df = (
             pd.read_csv(f)
             if f.name.endswith(".csv")
             else pd.DataFrame(f.read().decode().splitlines(), columns=["data"])
         )
         st.dataframe(df)
         st.subheader("Anomalies")
         st.dataframe(detect_anomalies(df))
         log_event(st.session_state.user, "AI threat run")
def email_protection():
     st.header("Email Protection")
     txt = st.text_area("Paste email text")
     if st.button("Scan"):
         if is_phishing(txt):
             st.error("Phishing!")
             st.write(explain_phishing_detection(txt))
         else:
             st.success("Looks clean")
         log_event(st.session_state.user, "Phishing scan")
def order_validation():
     st.header("Order Integrity")
     o = st.text_input("Order details")
     if st.button("Generate hash"):
         st.code(create_order_hash(o))
         log_event(st.session_state.user, "Hash generate")
def network_monitor():
     st.header("Network Monitor")
     logs = simulate_network_logs()
     st.subheader("Raw logs")
     st.json(logs)
     st.subheader("Suspicious")
     st.json(detect_suspicious_activity(logs))
     log_event(st.session_state.user, "View network")
def insider_monitoring():
     st.header("Insider Threats")
     logs = simulate_network_logs()
     st.json(analyze_behavior(logs))
     log_event(st.session_state.user, "Insider monitor")
 
def vulnerability_scanner():
     st.header("Vulnerability Scanner")
     f = st.file_uploader("Software list CSV/TXT")
     if f:
         vuln, err = scan_vulnerabilities(f)
         if err:
             st.error(err)
         elif vuln.empty:
             st.success("No vulnerable software")
         else:
             st.warning("Potential Issues")
             st.dataframe(vuln)
         log_event(st.session_state.user, "Vuln scan")
         
 # Cached PhishTank fetcher to avoid rate-limit issues
@st.cache_data(ttl=600)
def fetch_phishtank_data():
    data = {
        "url": [f"https://example{i}.phish.com" for i in range(1, 11)],
        "phish_detail_url": [f"https://details{i}.phish.com" for i in range(1, 11)],
        "submission_time": pd.date_range("2025-10-01", periods=10, freq="H")
    }
    return pd.DataFrame(data)


 # Initialize fullscreen state if not set
if "fullscreen_map" not in st.session_state:
     st.session_state["fullscreen_map"] = None

 # Global Attack Monitoring Page
def global_live_attack():
    st.header("Global Live Cyberattack Monitoring")
    # Initialize session variable
    if "fullscreen_map" not in st.session_state:
        st.session_state.fullscreen_map = None

    fullscreen = st.session_state.fullscreen_map

    # â”€â”€â”€ FULLSCREEN VIEWS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if fullscreen == "Fortinet":
        st.subheader("Fortinet Threat Map â€“ Full Screen View")
        components.iframe("https://threatmap.fortiguard.com", height=650)
        if st.button("Back to Grid View"):
            st.session_state.fullscreen_map = None
            st.rerun()

    elif fullscreen == "Bitdefender":
        st.subheader("Bitdefender Threat Map â€“ Full Screen View")
        components.iframe("https://threatmap.bitdefender.com", height=650)
        if st.button("Back to Grid View"):
            st.session_state.fullscreen_map = None
            st.rerun()

    elif fullscreen == "MITRE":
        st.subheader("MITRE ATT&CK â€“ Full Screen View")
        components.iframe("https://attack.mitre.org", height=700)
        if st.button("Back to Grid View"):
            st.session_state.fullscreen_map = None
            st.rerun()

    # â”€â”€â”€ GRID VIEW (DEFAULT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    else:
        st.markdown("#### ğŸ”¹ Threat Map Overview")
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Fortinet")
            components.iframe("https://threatmap.fortiguard.com", height=300)
            if st.button("Expand Fortinet"):
                st.session_state.fullscreen_map = "Fortinet"
                st.rerun()

        with col2:
            st.subheader("Bitdefender")
            components.iframe("https://threatmap.bitdefender.com", height=300)
            if st.button("Expand Bitdefender"):
                st.session_state.fullscreen_map = "Bitdefender"
                st.rerun()

        # Third row (single wide map)
        st.subheader("MITRE ATT&CK")
        components.iframe("https://attack.mitre.org", height=300)
        if st.button("Expand MITRE"):
            st.session_state.fullscreen_map = "MITRE"
            st.rerun()

        st.markdown("""
        ---
        Click any map to expand for a detailed view.  
        **Data sources:** Fortinet, Bitdefender, MITRE ATT&CK, and PhishTank.
        """)

        # â”€â”€â”€ Live PhishTank Feed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        st.subheader("ğŸª Live PhishTank Data (Top 10)")
        try:
            df_phish = fetch_phishtank_data().head(10)[["url", "phish_detail_url", "submission_time"]]
            st.dataframe(df_phish)
            st.caption("Data Source: PhishTank (auto-refreshed every 10 minutes)")
        except Exception as e:
            st.error(f"âš ï¸ Could not load PhishTank feed: {e}")

    st.markdown("---")
    st.subheader("Change Password")
    old_pw = st.text_input("Old Password", type="password")
    new_pw = st.text_input("New Password", type="password")
    confirm_pw = st.text_input("Confirm New Password", type="password")

    if st.button("Change Password"):
        if new_pw != confirm_pw:
            st.warning("New passwords do not match.")
        else:
            msg = change_user_password(st.session_state.user, old_pw, new_pw)
            if "successfully" in msg:
                st.success(msg)
                log_event(st.session_state.user, "Changed password")
            else:
                st.error(msg)

def admin_panel():
    st.header("ğŸ›¡ï¸ Admin Dashboard")

    # Section: Add New Admin
    st.subheader("â• Add New Admin")
    u = st.text_input("Username", key="new_admin_user")
    em = st.text_input("Email", key="new_admin_email")
    pw = st.text_input("Password", type="password", key="new_admin_pw")
    if st.button("Create Admin"):
        if u and em and pw:
            try:
                add_user(u, pw, em, adm=True)
                st.success(f"âœ… Admin '{u}' created successfully.")
                log_event(st.session_state.user, f"Added new admin {u}")
            except Exception as e:
                st.error(f"Failed: {e}")
        else:
            st.warning("Please fill all fields.")

    st.markdown("---")
    st.subheader("ğŸ‘ï¸ User Monitoring")

    # Display users and their roles
    conn = sqlite3.connect("users.db")
    users_df = pd.read_sql_query("SELECT username, email, is_admin FROM users", conn)
    logs_df = pd.read_sql_query("SELECT username, action, timestamp FROM activity_logs ORDER BY timestamp DESC", conn)
    conn.close()

    st.write("### Registered Users")
    st.dataframe(users_df)

    st.write("### User Activity Logs")
    st.dataframe(logs_df)

def profile_settings():
    st.header("ğŸ‘¤ Profile Settings")

    # Connect to database and fetch user info
    conn = sqlite3.connect("users.db")
    c = conn.cursor()
    c.execute("SELECT username, email FROM users WHERE username=?", (st.session_state.user,))
    row = c.fetchone()
    conn.close()

    if not row:
        st.error("User not found.")
        return

    current_username, current_email = row

    # --- Account Summary ---
    st.subheader("Account Summary")
    st.write(f"**Username:** {current_username}")
    st.write(f"**Email:** {current_email}")

    st.markdown("---")
    st.subheader("Update Profile Info")

    # Update user profile fields
    new_username = st.text_input("New Username", value=current_username)
    new_email = st.text_input("New Email", value=current_email)

    if st.button("Update Profile"):
        msg = update_user_profile(st.session_state.user, new_username, new_email)
        if "successfully" in msg.lower():
            st.success(msg)
            log_event(st.session_state.user, "Updated profile")

            # If username changed, update the session variable
            if new_username != st.session_state.user:
                st.session_state.user = new_username
                st.rerun()
        else:
            st.error(msg)

    # --- Change Password Section ---
    st.markdown("---")
    st.subheader("Change Password")

    old_pw = st.text_input("Old Password", type="password")
    new_pw = st.text_input("New Password", type="password")
    confirm_pw = st.text_input("Confirm New Password", type="password")

    if st.button("Change Password"):
        if new_pw != confirm_pw:
            st.warning("New passwords do not match.")
        else:
            msg = change_user_password(st.session_state.user, old_pw, new_pw)
            if "successfully" in msg.lower():
                st.success(msg)
                log_event(st.session_state.user, "Changed password")
            else:
                st.error(msg)
create_users_table()
ensure_reset_codes_table()
SESSION_DEFAULTS = {
     "logged_in": False,
     "is_admin": False,
     "user": "",
     "page": "auth",  # "auth" | "Dashboard" | any MODULE key
 }
 
for k, v in SESSION_DEFAULTS.items():
     st.session_state.setdefault(k, v)
MODULE_FUNCTIONS = {
     "A.I Threat Engine": ai_threat_engine,
     "Email Protection": email_protection,
     "Order Integrity": order_validation,
     "Network Monitor": network_monitor,
     "Insider Threats": insider_monitoring,
     "Vulnerability Scanner": vulnerability_scanner,
     "Global Live Attack": global_live_attack
 }
 # â”€â”€â”€ Sidebar Navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
with st.sidebar:
    if st.session_state.page == "auth":
        nav = st.radio("Menu", ["Login", "Sign Up", "Forgot Password"], key="auth_nav")
    else:
        nav = st.radio(
            "Menu",
            ["Dashboard", "Profile Settings", "Logout"] + (["Admin"] if st.session_state.is_admin else []),
            key="main_nav",
        )         
 # â”€â”€â”€ 1) Login â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if st.session_state.page == "auth" and nav == "Login":
     st.subheader("Login")
     col1, col2 = st.columns(2)
     with col1:
         user_input = st.text_input("Username / Email", key="login_user")
     with col2:
        pwd_input = st.text_input("Password", type="password", key="login_pwd")
     if st.button("Sign In", key="login_btn"):
         user_row = fetch_user(user_input)
         if user_row and check_password(pwd_input, user_row["password_hash"]):
             st.session_state.logged_in = True
             st.session_state.user = user_row["username"]
             st.session_state.is_admin = user_row["is_admin"]
             st.session_state.page = "Dashboard"
             st.success("Login successful.")
             log_event(st.session_state.user, "Logged in")
             st.rerun()
         else:
             st.error("Invalid username/email or password.")
             
 # â”€â”€â”€ 2) Sign-Up â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
elif st.session_state.page == "auth" and nav == "Sign Up":
     st.subheader("Create an Account")
     u = st.text_input("Username", key="su_user")
     em = st.text_input("Email", key="su_email")
     pw = st.text_input("Password", type="password", key="su_pw")
     cpw = st.text_input("Confirm Password", type="password", key="su_cpw")
     st.info("Only normal users can self-register. Admins can only be added by the root admin.")
     adm = False

     if st.button("Register", key="su_btn"):
         if pw != cpw:
             st.warning("Passwords don't match.")
         else:
             try:
                 add_user(u, pw, em, adm)
                 st.success("User registered â€“ you can now log in.")
             except Exception as e:
                 st.error(str(e))
 # â”€â”€â”€ 3) Forgot-Password (stub) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
elif st.session_state.page == "auth" and nav == "Forgot Password":
    st.subheader("ğŸ” Reset Password via Email")

    email = st.text_input("Enter your registered email", key="fp_email")

    if st.button("Send OTP", key="send_otp_btn"):
        otp = send_otp(email)
        expiry = datetime.now().timestamp() + 300  # valid for 5 mins
        conn = sqlite3.connect("users.db")
        c = conn.cursor()

        # Ensure reset_codes table exists before inserting
        c.execute("""
            CREATE TABLE IF NOT EXISTS reset_codes(
                email TEXT PRIMARY KEY,
                code TEXT,
                expiry_time TEXT
            )
        """)
        c.execute(
            "REPLACE INTO reset_codes (email, code, expiry_time) VALUES (?, ?, ?)",
            (email, otp, expiry)
        )

        conn.commit()
        conn.close()
        st.success("OTP sent to your email (valid for 5 minutes).")

    otp_input = st.text_input("Enter OTP", key="fp_otp")
    new_pw = st.text_input("New Password", type="password", key="fp_new_pw")
    confirm_pw = st.text_input("Confirm Password", type="password", key="fp_confirm_pw")

    if st.button("Reset Password", key="reset_pw_btn"):
        conn = sqlite3.connect("users.db")
        c = conn.cursor()
        c.execute("SELECT code, expiry_time FROM reset_codes WHERE email=?", (email,))
        row = c.fetchone()

        if not row:
            st.error("No reset request found.")
        elif otp_input != row[0]:
            st.error("Invalid OTP.")
        elif datetime.now().timestamp() > float(row[1]):
            st.error("OTP expired.")
        elif new_pw != confirm_pw:
            st.error("Passwords do not match.")
        else:
            hashed = bcrypt.hashpw(new_pw.encode(), bcrypt.gensalt())
            c.execute("UPDATE users SET password=? WHERE email=?", (hashed, email))
            conn.commit()
            st.success("Password reset successfully! You can now log in.")
            st.session_state.page = "auth"

        conn.close()

 # â”€â”€â”€ 4) Main App (Dashboard & Modules) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if st.session_state.logged_in:
    st.sidebar.title("Navigation")

    if nav == "Logout":
        log_event(st.session_state.user, "Logged out")
        st.session_state.clear()
        st.rerun()

    elif nav == "Dashboard":
        # Elegant green header
        st.markdown(
            "<h2 style='color: #2ECC71;'>ğŸŒ Welcome to the AS Dashboard</h2>",
            unsafe_allow_html=True
        )

        # Harmonized yellow text
        st.markdown(
            """
            <p style='color: #F4D03F; font-size: 16px;'>
            Welcome to the <b style='color:#F7DC6F;'>Anomalyzed Sentinel Dashboard</b>.<br><br>
            Here you can explore various cybersecurity modules that monitor, detect, and analyze potential threats.<br><br>
            Select a module below to begin exploring threat intelligence, anomaly detection, and network defense insights.
            </p>
            """,
            unsafe_allow_html=True
        )

        st.markdown("---")
        st.header("ğŸ§© Select a Security Module")

        cols = st.columns(3)
        for i, mod in enumerate(MODULE_FUNCTIONS.keys()):
            with cols[i % 3]:
                if st.button(mod, key=f"mod_{mod}"):
                    st.session_state.page = mod
                    st.rerun()

    elif nav == "Profile Settings":
        profile_settings()

    elif nav == "Admin":
        admin_panel()
if st.session_state.get("page") in MODULE_FUNCTIONS:
     MODULE_FUNCTIONS[st.session_state["page"]]()

     # Show "Back to Dashboard" button after rendering the module
     if st.button("ğŸ”™ Back to Dashboard", key="back_btn"):
         st.session_state.page = "Dashboard"
         st.rerun()
       
import sqlite3
import bcrypt

username = "isaackmutembei"
email = "isaacksani352@gmail.com"
password_plain = "Admin@2025!"   # change this immediately after first login

conn = sqlite3.connect("users.db")
c = conn.cursor()

# Ensure users table exists (mirrors your app's create_users_table)
c.execute("""
CREATE TABLE IF NOT EXISTS users(
    username TEXT PRIMARY KEY,
    password BLOB NOT NULL,
    email TEXT UNIQUE NOT NULL,
    is_admin INTEGER DEFAULT 0,
    otp TEXT,
    otp_expiry TEXT,
    verified INTEGER DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)
""")

# Only insert if username/email not already present
c.execute("SELECT 1 FROM users WHERE username=? OR email=?", (username, email))
if c.fetchone():
    print("Admin user already exists â€” skipping creation.")
else:
    pw_hash = bcrypt.hashpw(password_plain.encode(), bcrypt.gensalt())
    c.execute(
        "INSERT INTO users (username, password, email, is_admin) VALUES (?, ?, ?, ?)",
        (username, pw_hash, email, 1),
    )
    conn.commit()
    print(f"Admin user created. Username: {username}  Password: {password_plain}")

conn.close()

