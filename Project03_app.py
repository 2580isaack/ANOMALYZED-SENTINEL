# -*- coding: utf-8 -*-
#"""VICTORPROJECT.ipynb

#Automatically generated by Colab.

#Original file is located at
    #https://colab.research.google.com/drive/1vkM4-cSMcSvKQve30U-8fcm4kB6I97u7
#"""

import streamlit as st
import sqlite3, smtplib, random, string, bcrypt, pandas as pd, json, re, hashlib, secrets
from typing import List
from email.message import EmailMessage
from datetime import datetime
import streamlit.components.v1 as components
 
 # ─── Streamlit Theme ───────────────────────────────────────────────────────────
st.set_page_config(page_title="ANOMALYZED SENTINEL", layout="wide")
st.markdown(
    """
    <style>
    .stApp {
        background: linear-gradient(to bottom, #cc99ff 4%, #999966 84%);
     }
     section[data-testid="stSidebar"] {
         background: rgb(166, 138, 77);
     }
     h1, h2, h3, h4, h5, h6 {
         color: #3df50a;
     }
     .stButton > button {
         color: #3df50a !important;
         font-weight: 900;
     }
     </style>
     """,
     unsafe_allow_html=True,
 )
 # ─── Database Helpers ──────────────────────────────────────────────────────────
def create_users_table():
     conn = sqlite3.connect("users.db")
     c = conn.cursor()
     c.execute(
         """CREATE TABLE IF NOT EXISTS users(
                username TEXT PRIMARY KEY,
                password BLOB,
                email    TEXT,
                is_admin INTEGER
         )"""
     )
     c.execute(
         """CREATE TABLE IF NOT EXISTS reset_codes(
                email TEXT PRIMARY KEY,
                code  TEXT
         )"""
     )
     c.execute(
         """CREATE TABLE IF NOT EXISTS activity_logs(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT,
                action   TEXT,
                timestamp TEXT
         )"""
     )
     conn.commit()
     conn.close()
def add_user(u, pw, email, adm=False):
     conn = sqlite3.connect("users.db")
     c = conn.cursor()
     if c.execute(
         "SELECT 1 FROM users WHERE username=? OR email=?", (u, email)
     ).fetchone():
         conn.close()
         raise ValueError("Username or email already exists.")
     c.execute(
         "INSERT INTO users VALUES (?, ?, ?, ?)",
         (u, bcrypt.hashpw(pw.encode(), bcrypt.gensalt()), email, int(adm)),
     )
     conn.commit()
     conn.close()
def login_user(u, pw):
     """
     Authenticate user by username and password.
     Returns (True, user_dict) on success, else (False, {}).
     """
     conn = sqlite3.connect("users.db")
     c = conn.cursor()
     row = c.execute(
         "SELECT password, is_admin FROM users WHERE username=?", (u,)
     ).fetchone()
     conn.close()
     if row and bcrypt.checkpw(pw.encode(), row[0]):
         return True, {"username": u, "is_admin": bool(row[1])}
     return False, {}
def log_event(user, action):
     conn = sqlite3.connect("users.db")
     conn.execute(
         "INSERT INTO activity_logs(username, action, timestamp) VALUES (?, ?, ?)",
         (user, action, datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
     )
     conn.commit()
     conn.close()
def delete_user(u):
     conn = sqlite3.connect("users.db")
     conn.execute("DELETE FROM users WHERE username=?", (u,))
     conn.commit()
     conn.close()
def fetch_user(username_or_email):
     """Retrieve user info from DB by username or email."""
     conn = sqlite3.connect("users.db")
     cursor = conn.cursor()
     cursor.execute(
         """
         SELECT username, email, password, is_admin
         FROM users
         WHERE username = ? OR email = ?
         """,
         (username_or_email, username_or_email),
     )
     row = cursor.fetchone()
     conn.close()
     if row:
         return {
             "username": row[0],
             "email": row[1],
             "password_hash": row[2],
             "is_admin": bool(row[3]),
         }
     return None
def check_password(plain_password, hashed_password):
     """Compare a plain text password with a hashed one using bcrypt."""
     return bcrypt.checkpw(plain_password.encode(), hashed_password)
     
 # ─── (Optional) Email OTP Helper ───────────────────────────────────────────────
    #Kept for future use, but NOT called anywhere.
def send_otp(email):
     otp = str(random.randint(100_000, 999_999))
     print(f"[DEBUG] Sending OTP {otp} to {email}")
     msg = EmailMessage()
     msg.set_content(f"Your One-Time Password (OTP) is: {otp}")
     msg["Subject"] = "Your OTP Code"
     msg["From"] = "isaackmutembei335@gmail.com"
     msg["To"] = email
     try:
         with smtplib.SMTP("smtp.gmail.com", 587) as server:
             server.starttls()
             server.login("isaackmutembei335@gmail.com", "ojaz blqw lmza kqpg")
             server.send_message(msg)
             print("[DEBUG] Email sent successfully.")
     except Exception as e:
         print("[ERROR] Failed to send OTP:", e)
 
     return otp
 # ─── Core Security / Analysis Functions ───────────────────────────────────────
def detect_anomalies(df):
     num = df.select_dtypes(include="number")
     if num.empty:
         raise ValueError("No numeric columns.")
     rs = num.sum(axis=1)
     return df[rs > rs.mean()]
_PAT = {
     "urgent": r"urgent",
     "click here": r"click\s+here",
     "verify": r"verify\s+(your\s+)?account",
     "login now": r"login\s+(now|here)",
     "update pass": r"update\s+(your\s+)?password",
     "acct suspend": r"account\s+(suspended|limited|compromised)",
     "security": r"security\s+(alert|update)",
     "unusual": r"unusual\s+activity",
     "confirm": r"confirm\s+your\s+identity",
     "request": r"provide\s+(credit\s+card|ssn|password)",
     "act now": r"(act\s+)?now\s+to\s+avoid\s+.*",
     "win": r"(you\s+have\s+)?won\s+.*",
 }
def is_phishing(txt): return any(re.search(p, txt.lower()) for p in _PAT.values())
def explain_phishing_detection(txt): return [k for k, p in _PAT.items() if re.search(p, txt.lower())]
def create_order_hash(o): return hashlib.sha256(json.dumps(o, sort_keys=True).encode()).hexdigest()
def scan_vulnerabilities(f):
     try:
         df = (
             pd.read_csv(f)
             if f.name.endswith(".csv")
             else pd.DataFrame(f.read().decode().splitlines(), columns=["software"])
         )
         vuln = df[
             df.apply(
                 lambda r: r.astype(str).str.contains("old|deprecated", case=False).any(),
                 axis=1,
             )
         ]
         return vuln, ""
     except Exception as e:
         return pd.DataFrame(), str(e)
def simulate_network_logs():
     ips = ["192.168.1.2", "10.0.0.5", "172.16.0.3", "203.0.113.10"]
     actions = ["login", "file_access", "failed_login", "port_scan", "data_transfer"]
     return [
         {
             "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
             "ip": random.choice(ips),
             "action": random.choice(actions),
             "status": random.choice(["success", "failure"]),
         }
         for _ in range(15)
     ]
def detect_suspicious_activity(logs):
     return [
         l
         for l in logs
         if l["action"] in ["failed_login", "port_scan"]
         or (l["action"] == "data_transfer" and l["status"] == "failure")
     ]
def analyze_behavior(logs):
     summ = {}
     for l in logs:
         summ.setdefault(l["ip"], {"logins": 0, "fail": 0, "scan": 0})
         if l["action"] == "login":
             summ[l["ip"]]["logins"] += 1
         elif l["action"] == "failed_login":
             summ[l["ip"]]["fail"] += 1
         elif l["action"] == "port_scan":
             summ[l["ip"]]["scan"] += 1
     return {ip: s for ip, s in summ.items() if s["fail"] >= 3 or s["scan"] > 0}
     
 # ─── Module Pages ──────────────────────────────────────────────────────────────
def ai_threat_engine():
     st.header("A.I Threat Engine")
     f = st.file_uploader("Upload CSV/TXT", type=["csv", "txt"])
     if f:
         df = (
             pd.read_csv(f)
             if f.name.endswith(".csv")
             else pd.DataFrame(f.read().decode().splitlines(), columns=["data"])
         )
         st.dataframe(df)
         st.subheader("Anomalies")
         st.dataframe(detect_anomalies(df))
         log_event(st.session_state.user, "AI threat run")
def email_protection():
     st.header("Email Protection")
     txt = st.text_area("Paste email text")
     if st.button("Scan"):
         if is_phishing(txt):
             st.error("Phishing!")
             st.write(explain_phishing_detection(txt))
         else:
             st.success("Looks clean")
         log_event(st.session_state.user, "Phishing scan")
def order_validation():
     st.header("Order Integrity")
     o = st.text_input("Order details")
     if st.button("Generate hash"):
         st.code(create_order_hash(o))
         log_event(st.session_state.user, "Hash generate")
def network_monitor():
     st.header("Network Monitor")
     logs = simulate_network_logs()
     st.subheader("Raw logs")
     st.json(logs)
     st.subheader("Suspicious")
     st.json(detect_suspicious_activity(logs))
     log_event(st.session_state.user, "View network")
def insider_monitoring():
     st.header("Insider Threats")
     logs = simulate_network_logs()
     st.json(analyze_behavior(logs))
     log_event(st.session_state.user, "Insider monitor")
 
def vulnerability_scanner():
     st.header("Vulnerability Scanner")
     f = st.file_uploader("Software list CSV/TXT")
     if f:
         vuln, err = scan_vulnerabilities(f)
         if err:
             st.error(err)
         elif vuln.empty:
             st.success("No vulnerable software")
         else:
             st.warning("Potential Issues")
             st.dataframe(vuln)
         log_event(st.session_state.user, "Vuln scan")
         
 # Cached PhishTank fetcher to avoid rate-limit issues
 @st.cache_data(ttl=600)
def fetch_phishtank_data():
     url = "http://data.phishtank.com/data/online-valid.csv"
     return pd.read_csv(url)


 # Initialize fullscreen state if not set
if "fullscreen_map" not in st.session_state:
     st.session_state["fullscreen_map"] = None

 # Global Attack Monitoring Page
def global_live_attack():
     st.header("Global Live Cyberattack Monitoring")
 
     # Get current fullscreen target
     fullscreen = st.session_state.fullscreen_map
 
     # FULLSCREEN:
     if fullscreen == "Fortinet":
         st.subheader("Fortinet Threat Map – Full Screen View")
         components.iframe("https://threatmap.fortiguard.com", height=650)
         if st.button("Back to Grid View"):
             st.session_state.fullscreen_map = None
             st.rerun()
 
     elif fullscreen == "Bitdefender":
         st.subheader("Bitdefender Threat Map – Full Screen View")
         components.iframe("https://threatmap.bitdefender.com", height=650)
         if st.button("Back to Grid View"):
             st.session_state.fullscreen_map = None
             st.rerun()
 
     elif fullscreen == "MITRE":
         st.subheader("MITRE ATT&CK – Full Screen View")
         components.iframe("https://attack.mitre.org", height=700)
         if st.button("Back to Grid View"):
             st.session_state.fullscreen_map = None
             st.rerun()
 
     else:
     # Normal 2x2 grid view
         col1, col2 = st.columns(2)
         with col1:
             st.subheader("Fortinet")
             components.iframe("https://threatmap.fortiguard.com", height=300)
             if st.button("Expand Fortinet"):
                 st.session_state.fullscreen_map = "Fortinet"
                 st.rerun()
 
         with col2:
             st.subheader("Bitdefender")
             components.iframe("https://threatmap.bitdefender.com", height=300)
             if st.button("Expand Bitdefender"):
                 st.session_state.fullscreen_map = "Bitdefender"
                 st.rerun()
 
         # Third row with 3 columns
         col1, col2, col3 = st.columns(3)
         with col3:
             st.subheader("MITRE ATT&CK")
             components.iframe("https://attack.mitre.org", height=300)
             if st.button("Expand MITRE"):
                 st.session_state.fullscreen_map = "MITRE"
                 st.rerun()
 
         st.markdown("""
         ---
         Click any map to expand for better viewing.
         **Data sources:** PhishTank, Fortinet, Bitdefender, MITRE ATT&CK
         """)
 
def admin_panel():
     st.header("Admin Panel (placeholder)")
     st.write("Implement admin features here.")
 
 create_users_table() # Call the function to create tables
 
 SESSION_DEFAULTS = {
     "logged_in": False,
     "is_admin": False,
     "user": "",
     "page": "auth",  # "auth" | "Dashboard" | any MODULE key
 }
 
for k, v in SESSION_DEFAULTS.items():
     st.session_state.setdefault(k, v)
 MODULE_FUNCTIONS = {
     "A.I Threat Engine": ai_threat_engine,
     "Email Protection": email_protection,
     "Order Integrity": order_validation,
     "Network Monitor": network_monitor,
     "Insider Threats": insider_monitoring,
     "Vulnerability Scanner": vulnerability_scanner,
     "Global Live Attack": global_live_attack
 }
 # ─── Sidebar Navigation ───────────────────────────────────────────────────────
with st.sidebar:
     if st.session_state.page == "auth":
         nav = st.radio("Menu", ["Login", "Sign Up", "Forgot Password"], key="auth_nav")
     else:
         nav = st.radio(
             "Menu",
             ["Dashboard", "Logout"] + (["Admin"] if st.session_state.is_admin else []),
             key="main_nav",
         )
         
 # ─── 1) Login ────────────────────────────────────────────────────────────────
if st.session_state.page == "auth" and nav == "Login":
     st.subheader("Login")
     col1, col2 = st.columns(2)
     with col1:
         user_input = st.text_input("Username / Email", key="login_user")
     with col2:
        pwd_input = st.text_input("Password", type="password", key="login_pwd")
     if st.button("Sign In", key="login_btn"):
         user_row = fetch_user(user_input)
         if user_row and check_password(pwd_input, user_row["password_hash"]):
             st.session_state.logged_in = True
             st.session_state.user = user_row["username"]
             st.session_state.is_admin = user_row["is_admin"]
             st.session_state.page = "Dashboard"
             st.success("Login successful.")
             log_event(st.session_state.user, "Logged in")
             st.rerun()
         else:
             st.error("Invalid username/email or password.")
             
 # ─── 2) Sign-Up ───────────────────────────────────────────────────────────────
elif st.session_state.page == "auth" and nav == "Sign Up":
     st.subheader("Create an Account")
     u = st.text_input("Username", key="su_user")
     em = st.text_input("Email", key="su_email")
     pw = st.text_input("Password", type="password", key="su_pw")
     cpw = st.text_input("Confirm Password", type="password", key="su_cpw")
     adm = st.checkbox("Admin?", key="su_admin")
     if st.button("Register", key="su_btn"):
         if pw != cpw:
             st.warning("Passwords don't match.")
         else:
             try:
                 add_user(u, pw, em, adm)
                 st.success("User registered – you can now log in.")
             except Exception as e:
                 st.error(str(e))
 # ─── 3) Forgot-Password (stub) ───────────────────────────────────────────────
elif st.session_state.page == "auth" and nav == "Forgot Password":
     st.info("Forgot-password flow goes here.")
 # ─── 4) Main App (Dashboard & Modules) ───────────────────────────────────────
if st.session_state.logged_in:
     st.sidebar.title("Navigation")
     if nav == "Logout":
         log_event(st.session_state.user, "Logged out")
         st.session_state.clear()
         st.rerun()
     elif nav == "Dashboard":
         st.header("Select a Module")
         cols = st.columns(3)
         for i, mod in enumerate(MODULE_FUNCTIONS.keys()):
             with cols[i % 3]:
                 if st.button(mod, key=f"mod_{mod}"):
                     st.session_state.page = mod
                     st.rerun()
     elif nav == "Admin":
         admin_panel()
 
if st.session_state.get("page") in MODULE_FUNCTIONS:
     MODULE_FUNCTIONS[st.session_state["page"]]()

     # Show "Back to Dashboard" button after rendering the module
     if st.button("🔙 Back to Dashboard", key="back_btn"):
         st.session_state.page = "Dashboard"
         st.rerun()
